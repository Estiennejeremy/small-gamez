<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Hacking Grid - Casse-t√™te</title>
  <style>
    body {
      margin: 0;
      padding: 15px;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0f0f23 100%);
      font-family: 'Courier New', monospace;
      color: #00ff00;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    h1 {
      font-size: 1.8em;
      margin: 15px 0;
      text-align: center;
      color: #00ff00;
      text-shadow: 
        0 0 15px rgba(0, 255, 0, 0.8),
        0 0 30px rgba(0, 255, 0, 0.4);
      letter-spacing: 3px;
      font-weight: bold;
    }

    canvas {
      border: 3px solid #00ff00;
      background: radial-gradient(circle at center, rgba(0, 20, 0, 0.95), rgba(0, 0, 0, 0.98));
      border-radius: 12px;
      box-shadow: 
        0 0 20px rgba(0, 255, 0, 0.4),
        inset 0 0 50px rgba(0, 255, 0, 0.1);
      touch-action: none;
      max-width: 100%;
      height: auto;
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
    }

    #controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 20px;
      background: linear-gradient(45deg, rgba(0, 255, 0, 0.1), rgba(0, 255, 0, 0.05));
      border: 2px solid #00ff00;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 8px;
      font-size: 14px;
      touch-action: manipulation;
      min-width: 100px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0, 255, 0, 0.2);
    }

    button:hover, button:active {
      background: linear-gradient(45deg, rgba(0, 255, 0, 0.25), rgba(0, 255, 0, 0.15));
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 255, 0, 0.3);
    }

    #rules {
      margin: 15px 0;
      color: #00ff00;
      text-align: center;
      font-size: 12px;
      max-width: 100%;
      line-height: 1.5;
      padding: 0 10px;
      box-sizing: border-box;
    }

    #winImage {
      display: none;
      margin: 20px 0;
      border: 3px solid #00ff00;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      height: auto;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
      animation: winGlow 2s ease-in-out infinite alternate;
    }

    @keyframes winGlow {
      from { box-shadow: 0 0 20px rgba(0, 255, 0, 0.6); }
      to { box-shadow: 0 0 30px rgba(0, 255, 0, 0.9); }
    }

    .rule-highlight {
      color: #ffff00;
      font-weight: bold;
    }

    #selectedInfo {
      margin: 10px 0;
      padding: 12px 16px;
      background: linear-gradient(45deg, rgba(0, 255, 0, 0.15), rgba(0, 255, 0, 0.05));
      border: 2px solid #00ff00;
      border-radius: 8px;
      font-size: 14px;
      min-height: 20px;
      text-align: center;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
      backdrop-filter: blur(5px);
    }

    #connectionMode {
      margin: 10px 0;
      padding: 10px 16px;
      background: linear-gradient(45deg, rgba(255, 255, 0, 0.2), rgba(255, 255, 0, 0.08));
      border: 2px solid #ffff00;
      border-radius: 8px;
      font-size: 12px;
      text-align: center;
      color: #ffff00;
      text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.2);
    }

    /* Responsive design */
    @media (max-width: 480px) {
      body {
        padding: 5px;
      }
      
      h1 {
        font-size: 1.2em;
        margin: 5px 0;
      }
      
      #rules {
        font-size: 11px;
        margin: 10px 0;
      }
      
      button {
        padding: 10px 15px;
        font-size: 12px;
        min-width: 80px;
      }
    }

    @media (max-height: 600px) {
      body {
        padding: 5px;
      }
      
      #rules {
        font-size: 10px;
        margin: 8px 0;
      }
      
      h1 {
        font-size: 1.1em;
        margin: 5px 0;
      }
    }
  </style>
</head>
<body>
  <h1>üîì HACKING GRID</h1>
  
  <div id="gameContainer">
    <canvas id="gameCanvas" width="700" height="560"></canvas>
    
    <div id="selectedInfo">Touchez un point pour le s√©lectionner</div>
    
    <div id="connectionMode" style="display: none;">
      Mode connexion : Touchez un autre point pour le relier
    </div>
    
    <div id="controls">
      <button id="resetBtn">üîÑ Recommencer</button>
      <button id="clearBtn">üóëÔ∏è Effacer</button>
    </div>
    
    <div id="rules">
      <span class="rule-highlight">üìã R√àGLES DU CASSE-T√äTE</span><br />
      ‚Ä¢ Connexions uniquement <span class="rule-highlight">verticales et horizontales</span><br />
      ‚Ä¢ Aucun croisement de lignes autoris√©<br />
      ‚Ä¢ Maximum <span class="rule-highlight">2 connexions</span> entre deux points<br />
      ‚Ä¢ Maximum <span class="rule-highlight">4 connexions</span> par point<br />
      ‚Ä¢ Chaque point doit atteindre son nombre exact de connexions<br />
      ‚Ä¢ <span class="rule-highlight">Couleurs :</span> üü¢ Simple ‚Ä¢ üîµ Double<br />
      <em>üì± Touchez deux points pour cr√©er ‚Ä¢ Touchez une ligne pour supprimer</em>
    </div>
  </div>

  <img id="winImage" src="win.jpg" alt="F√©licitations !" />
  
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const winImage = document.getElementById("winImage");
    const resetBtn = document.getElementById("resetBtn");
    const clearBtn = document.getElementById("clearBtn");
    const selectedInfo = document.getElementById("selectedInfo");
    const connectionMode = document.getElementById("connectionMode");

    // Ajuste la taille du canvas pour mobile
    function resizeCanvas() {
      const container = document.getElementById("gameContainer");
      const maxWidth = Math.min(window.innerWidth - 20, 800);
      const maxHeight = Math.min(window.innerHeight * 0.6, 560);
      
      canvas.width = maxWidth;
      canvas.height = maxHeight;
      
      // Redessine apr√®s redimensionnement
      if (nodes.length > 0) {
        generatePuzzleGrid();
        draw();
      }
    }

    // Redimensionne au chargement et lors du changement d'orientation
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 100);
    });

    const nodeRadius = 35; // Augment√© pour une meilleure visibilit√©
    let selectedNode = null;
    const nodes = [];
    const connections = [];

    // G√©n√®re une grille de casse-t√™te avec solution unique v√©rifi√©e
    function generatePuzzleGrid() {
      // Grille asym√©trique 5x6 - r√©seau unique connect√© garantit
      const nodeLayout = [
        [1, 0, 1, 1, 0, 1],
        [0, 1, 0, 0, 1, 0],
        [1, 0, 1, 0, 1, 1],
        [0, 1, 0, 1, 0, 0],
        [1, 0, 1, 1, 0, 1]
      ];
      
      // Solution formant un arbre connect√© - tous points reli√©s en un r√©seau unique
      // Arbre principal: (0-0)-(2-0)-(4-0)-(4-2)-(4-3)-(3-3)-(1-4)-(2-4)-(2-5)-(0-5)-(0-3)-(0-2)-(2-2)-(1-1)-(3-1)
      const maxConnections = {
        // Feuilles de l'arbre (1 connexion)
        "0-0": 2, "1-1": 1, "2-5": 1, "3-1": 2, "0-5": 1,
        // N≈ìuds de liaison (2 connexions)
        "0-2": 3, "0-3": 2, "1-4": 2, "2-0": 3, "2-2": 2, "2-4": 3, "3-3": 3, "4-0": 4, "4-3": 4, "4-5": 2,
        // Hub central (3 connexions)
        "4-2": 3
      };

      const gridRows = nodeLayout.length;
      const gridCols = nodeLayout[0].length;
      
      // Calcule la taille de grille avec plus d'espacement pour √©viter le chevauchement
      const minSpacing = 80; // Espacement minimum entre les points
      const gridSizeX = Math.max(minSpacing, (canvas.width - 100) / (gridCols - 1));
      const gridSizeY = Math.max(minSpacing, (canvas.height - 100) / (gridRows - 1));
      
      const totalWidth = (gridCols - 1) * gridSizeX;
      const totalHeight = (gridRows - 1) * gridSizeY;
      const xOffset = (canvas.width - totalWidth) / 2;
      const yOffset = (canvas.height - totalHeight) / 2;
      
      nodes.length = 0;
      connections.length = 0;
      
      for (let y = 0; y < gridRows; y++) {
        for (let x = 0; x < gridCols; x++) {
          if (nodeLayout[y][x]) {
            const key = `${y}-${x}`;
            nodes.push({
              id: key,
              x: x * gridSizeX + xOffset,
              y: y * gridSizeY + yOffset,
              connections: 0,
              max: maxConnections[key] || 1,
            });
          }
        }
      }
      
      selectedNode = null;
      updateSelectedInfo();
    }

    function updateSelectedInfo() {
      if (selectedNode) {
        selectedInfo.textContent = `Point s√©lectionn√© : ${selectedNode.connections}/${selectedNode.max} connexions`;
        connectionMode.style.display = 'block';
      } else {
        selectedInfo.textContent = "Touchez un point pour le s√©lectionner";
        connectionMode.style.display = 'none';
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Debug: affiche le nombre de connexions
      console.log('Nombre de connexions:', connections.length);

      // Dessine les connexions avec gestion des connexions multiples
      if (connections.length > 0) {
        ctx.save();
        
        // Groupe les connexions par paire de n≈ìuds
        const connectionGroups = {};
        for (const conn of connections) {
          const key = [conn[0], conn[1]].sort().join('-');
          if (!connectionGroups[key]) {
            connectionGroups[key] = [];
          }
          connectionGroups[key].push(conn);
        }
        
        // Dessine chaque groupe de connexions
        for (const [key, connGroup] of Object.entries(connectionGroups)) {
          const node1 = nodes.find(n => n.id === connGroup[0][0]);
          const node2 = nodes.find(n => n.id === connGroup[0][1]);
          
          if (node1 && node2) {
            const numConnections = connGroup.length;
            
            // Calcule la direction perpendiculaire pour d√©caler les lignes
            const dx = node2.x - node1.x;
            const dy = node2.y - node1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // Vecteur perpendiculaire normalis√©
            const perpX = -dy / length;
            const perpY = dx / length;
            
            // D√©calage pour chaque connexion
            const baseOffset = 8; // pixels
            
            for (let i = 0; i < numConnections; i++) {
              let offset = 0;
              
              if (numConnections === 2) {
                offset = (i === 0) ? -baseOffset : baseOffset;
              } else if (numConnections === 3) {
                offset = (i === 0) ? -baseOffset : (i === 1) ? 0 : baseOffset;
              }
              
              const x1 = node1.x + perpX * offset;
              const y1 = node1.y + perpY * offset;
              const x2 = node2.x + perpX * offset;
              const y2 = node2.y + perpY * offset;
              
              // Couleur diff√©rente selon le nombre de connexions
              let strokeColor = '#00ff00';
              if (numConnections === 2) strokeColor = '#00ffff';
              if (numConnections >= 3) strokeColor = '#ffff00';
              
              // Trait de fond blanc pour contraste
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 10;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
              
              // Trait principal color√©
              ctx.strokeStyle = strokeColor;
              ctx.lineWidth = 6;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
              
              // Ligne centrale plus fine pour les connexions multiples
              if (numConnections > 1) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
              }
            }
          }
        }
        
        ctx.restore();
      }

      // Dessine les n≈ìuds avec des effets visuels am√©lior√©s
      for (const node of nodes) {
        const complete = node.connections === node.max;
        const overLimit = node.connections > 6;
        
        // Ombre port√©e
        ctx.beginPath();
        ctx.arc(node.x + 3, node.y + 3, nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fill();
        
        // Cercle principal avec d√©grad√©
        const gradient = ctx.createRadialGradient(
          node.x - 10, node.y - 10, 0,
          node.x, node.y, nodeRadius
        );
        
        if (overLimit) {
          gradient.addColorStop(0, '#ff6666');
          gradient.addColorStop(1, '#cc0000');
          ctx.strokeStyle = '#ff0000';
        } else if (complete) {
          gradient.addColorStop(0, '#66ff66');
          gradient.addColorStop(1, '#00cc00');
          ctx.strokeStyle = '#00ff00';
        } else {
          gradient.addColorStop(0, '#334433');
          gradient.addColorStop(1, '#001100');
          ctx.strokeStyle = '#00ff00';
        }
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.stroke();

        // Cercle int√©rieur pour plus de profondeur
        ctx.beginPath();
        ctx.arc(node.x, node.y, nodeRadius - 8, 0, Math.PI * 2);
        ctx.strokeStyle = complete ? '#00ff00' : '#004400';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Fonction pour afficher des points en motif de domino
        function drawDots(x, y, current, max, isComplete) {
          const dotRadius = 4;
          const spacing = 12;
          
          // Positions des points selon les motifs de domino
          const dominoPatterns = {
            1: [[0, 0]],
            2: [[-spacing/2, -spacing/2], [spacing/2, spacing/2]],
            3: [[-spacing/2, -spacing/2], [0, 0], [spacing/2, spacing/2]],
            4: [[-spacing/2, -spacing/2], [spacing/2, -spacing/2], 
                [-spacing/2, spacing/2], [spacing/2, spacing/2]],
            5: [[-spacing/2, -spacing/2], [spacing/2, -spacing/2], [0, 0],
                [-spacing/2, spacing/2], [spacing/2, spacing/2]],
            6: [[-spacing/2, -spacing*0.8], [-spacing/2, 0], [-spacing/2, spacing*0.8],
                [spacing/2, -spacing*0.8], [spacing/2, 0], [spacing/2, spacing*0.8]]
          };
          
          const pattern = dominoPatterns[max] || [[0, 0]];
          
          for (let i = 0; i < pattern.length; i++) {
            const dotX = x + pattern[i][0];
            const dotY = y + pattern[i][1];
            
            ctx.beginPath();
            ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
            
            // Ombre pour meilleure visibilit√©
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(dotX - 1, dotY - 1, dotRadius, 0, Math.PI * 2);
            
            // Points remplis pour les connexions actuelles, vides pour les restantes
            if (i < current) {
              ctx.fillStyle = isComplete ? '#ffffff' : '#00ff00';
              ctx.fill();
              // Contour pour plus de visibilit√©
              ctx.strokeStyle = '#004400';
              ctx.lineWidth = 1;
              ctx.stroke();
            } else {
              ctx.fillStyle = '#222222';
              ctx.fill();
              ctx.strokeStyle = '#888888';
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          }
        }
        
        // Affiche les points au lieu des chiffres
        drawDots(node.x, node.y, node.connections, node.max, complete);
      }

      // Surligne le n≈ìud s√©lectionn√© avec des effets lumineux
      if (selectedNode) {
        // Effet de pulsation lumineux
        const pulseRadius = nodeRadius + 15 + Math.sin(Date.now() * 0.008) * 5;
        
        // Halo externe
        const haloGradient = ctx.createRadialGradient(
          selectedNode.x, selectedNode.y, nodeRadius + 5,
          selectedNode.x, selectedNode.y, pulseRadius
        );
        haloGradient.addColorStop(0, 'rgba(255, 255, 0, 0.6)');
        haloGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
        
        ctx.beginPath();
        ctx.arc(selectedNode.x, selectedNode.y, pulseRadius, 0, Math.PI * 2);
        ctx.fillStyle = haloGradient;
        ctx.fill();
        
        // Cercle de s√©lection anim√©
        ctx.strokeStyle = '#ffff00';
        ctx.setLineDash([10, 10]);
        ctx.lineDashOffset = -Date.now() * 0.01;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(selectedNode.x, selectedNode.y, nodeRadius + 12, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      checkWin();
    }

    function getNodeAt(x, y) {
      return nodes.find(n => Math.hypot(n.x - x, n.y - y) < nodeRadius);
    }

    function connectionCount(id1, id2) {
      return connections.filter(c => (c[0] === id1 && c[1] === id2) || (c[0] === id2 && c[1] === id1)).length;
    }

    // Fonction pour v√©rifier si deux segments se croisent
    function segmentsIntersect(p1, q1, p2, q2) {
      // Trouve l'orientation du triplet ordonn√© (p, q, r)
      function orientation(p, q, r) {
        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        if (val === 0) return 0;
        return (val > 0) ? 1 : 2;
      }

      // V√©rifie si le point q est sur le segment pr
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
               q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }

      const o1 = orientation(p1, q1, p2);
      const o2 = orientation(p1, q1, q2);
      const o3 = orientation(p2, q2, p1);
      const o4 = orientation(p2, q2, q1);

      // Cas g√©n√©ral
      if (o1 !== o2 && o3 !== o4) return true;

      // Cas sp√©ciaux pour les points colin√©aires
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;

      return false;
    }

    function canConnect(node1, node2) {
      const [y1, x1] = node1.id.split('-').map(Number);
      const [y2, x2] = node2.id.split('-').map(Number);
      
      // V√©rifie que la connexion est horizontale ou verticale
      if (y1 !== y2 && x1 !== x2) {
        return false;
      }
      
      // V√©rifie les obstacles (points entre les deux n≈ìuds)
      if (y1 === y2) {
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        
        for (let x = minX + 1; x < maxX; x++) {
          const obstacleId = `${y1}-${x}`;
          if (nodes.find(n => n.id === obstacleId)) {
            return false;
          }
        }
      } else {
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);
        
        for (let y = minY + 1; y < maxY; y++) {
          const obstacleId = `${y}-${x1}`;
          if (nodes.find(n => n.id === obstacleId)) {
            return false;
          }
        }
      }
      
      // V√©rifie qu'aucune connexion existante ne croise cette nouvelle connexion
      const newSegmentStart = { x: node1.x, y: node1.y };
      const newSegmentEnd = { x: node2.x, y: node2.y };
      
      for (const conn of connections) {
        // Ignore la connexion avec les m√™mes n≈ìuds
        if ((conn[0] === node1.id && conn[1] === node2.id) || 
            (conn[0] === node2.id && conn[1] === node1.id)) {
          continue;
        }
        
        const connNode1 = nodes.find(n => n.id === conn[0]);
        const connNode2 = nodes.find(n => n.id === conn[1]);
        
        if (connNode1 && connNode2) {
          const existingSegmentStart = { x: connNode1.x, y: connNode1.y };
          const existingSegmentEnd = { x: connNode2.x, y: connNode2.y };
          
          // V√©rifie le croisement (ignore si les segments partagent un point commun)
          if ((newSegmentStart.x !== existingSegmentStart.x || newSegmentStart.y !== existingSegmentStart.y) &&
              (newSegmentStart.x !== existingSegmentEnd.x || newSegmentStart.y !== existingSegmentEnd.y) &&
              (newSegmentEnd.x !== existingSegmentStart.x || newSegmentEnd.y !== existingSegmentStart.y) &&
              (newSegmentEnd.x !== existingSegmentEnd.x || newSegmentEnd.y !== existingSegmentEnd.y)) {
            
            if (segmentsIntersect(newSegmentStart, newSegmentEnd, existingSegmentStart, existingSegmentEnd)) {
              return false;
            }
          }
        }
      }
      
      return true;
    }

    // V√©rifie si tous les points forment une seule structure connect√©e
    function isFullyConnected() {
      if (nodes.length === 0) return true;
      if (connections.length === 0) return false;
      
      console.log('V√©rification connexit√© - N≈ìuds:', nodes.length, 'Connexions:', connections.length);
      
      // Construit le graphe des connexions
      const graph = {};
      nodes.forEach(node => {
        graph[node.id] = [];
      });
      
      connections.forEach(conn => {
        console.log('Connexion:', conn[0], '->', conn[1]);
        if (graph[conn[0]] && graph[conn[1]]) {
          graph[conn[0]].push(conn[1]);
          graph[conn[1]].push(conn[0]);
        }
      });
      
      console.log('Graphe construit:', graph);
      
      // Parcours en profondeur depuis le premier n≈ìud
      const visited = new Set();
      const stack = [nodes[0].id];
      
      while (stack.length > 0) {
        const current = stack.pop();
        if (visited.has(current)) continue;
        
        visited.add(current);
        console.log('Visit√©:', current);
        
        // Ajoute tous les voisins non visit√©s
        if (graph[current]) {
          graph[current].forEach(neighbor => {
            if (!visited.has(neighbor)) {
              stack.push(neighbor);
            }
          });
        }
      }
      
      console.log('N≈ìuds visit√©s:', visited.size, '/', nodes.length);
      console.log('Visited set:', Array.from(visited));
      
      // V√©rifie si tous les n≈ìuds ont √©t√© visit√©s
      const result = visited.size === nodes.length;
      console.log('Connexit√© compl√®te:', result);
      return result;
    }

    function checkWin() {
      const allCorrect = nodes.every(n => n.connections === n.max);
      const noOverLimit = nodes.every(n => n.connections <= 6);
      const fullyConnected = isFullyConnected();
      
      if (allCorrect && noOverLimit && fullyConnected) {
        winImage.style.display = 'block';
        selectedInfo.textContent = "üéâ F√©licitations ! Vous avez r√©solu le puzzle !";
        connectionMode.style.display = 'none';
      } else {
        winImage.style.display = 'none';
        
        // Message d'aide si les quotas sont corrects mais pas connect√©
        if (allCorrect && noOverLimit && !fullyConnected) {
          selectedInfo.textContent = "‚ö†Ô∏è Tous les points doivent former une seule structure !";
        }
      }
    }

    function removeConnectionAt(x, y) {
      console.log(`Tentative de suppression √† x:${x}, y:${y}`);
      
      // Groupe les connexions par paires pour g√©rer les connexions multiples
      const connectionGroups = {};
      connections.forEach((conn, index) => {
        const key = [conn[0], conn[1]].sort().join('-');
        if (!connectionGroups[key]) {
          connectionGroups[key] = [];
        }
        connectionGroups[key].push({ conn, index });
      });
      
      // Parcourt chaque groupe de connexions
      for (const [key, connGroup] of Object.entries(connectionGroups)) {
        const node1 = nodes.find(n => n.id === connGroup[0].conn[0]);
        const node2 = nodes.find(n => n.id === connGroup[0].conn[1]);
        
        if (!node1 || !node2) continue;
        
        // V√©rifie si le clic est proche de cette paire de n≈ìuds
        const dx = node2.x - node1.x;
        const dy = node2.y - node1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length === 0) continue;
        
        // Projette le point cliqu√© sur la ligne principale
        const t = Math.max(0, Math.min(1, ((x - node1.x) * dx + (y - node1.y) * dy) / (length * length)));
        const projX = node1.x + t * dx;
        const projY = node1.y + t * dy;
        
        // Distance du point cliqu√© au point projet√©
        const distance = Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY));
        
        console.log(`Groupe ${key}: distance = ${distance}, connexions = ${connGroup.length}`);
        
        // Si le clic est proche des lignes (tol√©rance augment√©e √† 30 pixels pour les multiples)
        if (distance < 30) {
          console.log(`Suppression d'une connexion entre ${node1.id} et ${node2.id}`);
          
          // Supprime une seule connexion du groupe
          const indexToRemove = connGroup[connGroup.length - 1].index;
          connections.splice(indexToRemove, 1);
          node1.connections--;
          node2.connections--;
          return true;
        }
      }
      
      console.log("Aucune connexion trouv√©e √† supprimer");
      return false;
    }

    function handleTouch(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      
      // Gestion des coordonn√©es pour les √©v√©nements tactiles et souris
      let x, y;
      if (e.type === 'touchstart') {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }

      // V√©rifie d'abord si on clique sur un n≈ìud
      const clicked = getNodeAt(x, y);
      
      // Si on a cliqu√© sur un n≈ìud, on g√®re uniquement la s√©lection/connexion
      if (clicked) {
        if (!selectedNode) {
          selectedNode = clicked;
        } else if (selectedNode.id === clicked.id) {
          selectedNode = null;
        } else {
          const hasLineOfSight = canConnect(selectedNode, clicked);
          const existingConnections = connectionCount(selectedNode.id, clicked.id);
          const canAddConnection = 
            hasLineOfSight &&
            selectedNode.connections < selectedNode.max &&
            clicked.connections < clicked.max &&
            selectedNode.connections < 6 &&
            clicked.connections < 6 &&
            existingConnections < 2;

          if (canAddConnection) {
            connections.push([selectedNode.id, clicked.id]);
            selectedNode.connections++;
            clicked.connections++;
          }
          
          selectedNode = null;
        }
      } else {
        // Si on n'a pas cliqu√© sur un n≈ìud, on essaie de supprimer une connexion
        if (removeConnectionAt(x, y)) {
          selectedNode = null;
        }
      }

      updateSelectedInfo();
      draw();
    }

    // √âv√©nements tactiles et souris
    canvas.addEventListener("touchstart", handleTouch);
    canvas.addEventListener("click", handleTouch);

    // Emp√™che le zoom sur double tap
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
    });

    // Bouton de reset
    resetBtn.addEventListener("click", () => {
      generatePuzzleGrid();
      draw();
    });

    // Bouton pour effacer toutes les connexions
    clearBtn.addEventListener("click", () => {
      connections.length = 0;
      nodes.forEach(node => node.connections = 0);
      selectedNode = null;
      updateSelectedInfo();
      draw();
    });

    // Animation continue pour les effets visuels
    function animate() {
      draw();
      requestAnimationFrame(animate);
    }

    // Initialisation
    resizeCanvas();
    generatePuzzleGrid();
    animate();
  </script>
</body>
</html>
